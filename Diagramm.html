<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <title>UL(E) und IK(E) Diagramm</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      margin: 0;
      padding: 20px;
      background: #f5f5f5;
      color: #111827;
    }

    h1 {
      font-size: 1.4rem;
      margin-bottom: 0.5rem;
    }

    h2 {
      font-size: 1.2rem;
      margin: 0 0 0.5rem;
    }

    .container {
      max-width: 900px;
      margin: 0 auto 24px;
      background: #ffffff;
      padding: 20px;
      border-radius: 16px;
      box-shadow: 0 10px 25px rgba(0,0,0,0.06);
    }

    label {
      font-size: 0.9rem;
      font-weight: 600;
      display: block;
      margin-bottom: 4px;
    }

    textarea, input[type="number"] {
      width: 100%;
      box-sizing: border-box;
      padding: 8px;
      border-radius: 8px;
      border: 1px solid #ccc;
      font-family: inherit;
      font-size: 0.9rem;
      resize: vertical;
      min-height: 60px;
    }

    input[type="number"] {
      min-height: auto;
    }

    .hint {
      font-size: 0.75rem;
      color: #666;
      margin-top: 2px;
    }

    button {
      padding: 10px 16px;
      border-radius: 999px;
      border: none;
      font-weight: 600;
      cursor: pointer;
      font-size: 0.95rem;
      margin-top: 4px;
    }

    #plotBtn, #plotAngleBtn {
      background: #2563eb;
      color: #ffffff;
    }

    #resetBtn, #resetAngleBtn {
      background: #e5e7eb;
      color: #111827;
      margin-left: 8px;
    }

    .status {
      color: #b91c1c;
      font-size: 0.8rem;
      margin-top: 8px;
      min-height: 1em;
    }

    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 16px;
      margin-bottom: 16px;
    }

    .chart-container {
      margin-top: 20px;
    }

    canvas {
      background: #ffffff;
      border-radius: 12px;
    }

    .table-wrapper {
      overflow-x: auto;
      margin-bottom: 12px;
    }

    .data-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.9rem;
    }

    .data-table th,
    .data-table td {
      border: 1px solid #d1d5db;
      padding: 8px;
      text-align: left;
    }

    .data-table th {
      background: #f3f4f6;
      font-weight: 600;
    }

    .table-actions {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 8px;
      justify-content: space-between;
    }

    .button-group {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
    }

    .table-actions .status {
      flex: 1;
      min-width: 200px;
    }

    .measurement-input {
      width: 100%;
      padding: 6px;
      border-radius: 8px;
      border: 1px solid #d1d5db;
      font-size: 0.9rem;
      font-family: inherit;
      box-sizing: border-box;
    }

    .dataset-toggles {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      margin-top: 12px;
      font-size: 0.85rem;
    }

    .dataset-toggles label {
      font-weight: 500;
      display: flex;
      align-items: center;
      gap: 6px;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Diagramm: UL = f(E) und IK = f(E)</h1>
    <p>Trage deine Messreihen tabellarisch ein, damit direkt ersichtlich ist, welches <strong>E</strong> zu welchem <strong>UL</strong> und <strong>IK</strong> gehört.</p>

    <div class="table-wrapper">
      <table class="data-table">
        <thead>
          <tr>
            <th>E</th>
            <th>UL</th>
            <th>IK</th>
          </tr>
        </thead>
        <tbody id="measurementBody"></tbody>
      </table>
    </div>

    <div class="table-actions">
      <div class="button-group">
        <button id="plotBtn">Zeichnen</button>
        <button id="resetBtn" type="button">Zurücksetzen</button>
        <button id="addRowBtn" type="button">+ Zeile</button>
      </div>
      <div id="error" class="status"></div>
    </div>

    <div class="dataset-toggles">
      <label><input type="checkbox" id="toggleUL" checked> UL(E) anzeigen</label>
      <label><input type="checkbox" id="toggleIK" checked> IK(E) anzeigen</label>
    </div>

    <div class="chart-container">
      <canvas id="myChart" height="180"></canvas>
    </div>
  </div>

  <div class="container">
    <h2>Tabelle zwei: IK in Abhängigkeit vom Winkel</h2>
    <p>Trage hier die gemessenen Stromstärken <strong>IK</strong> für die Winkel in Grad ein. Das Diagramm darunter zeigt die Werte aufgetragen mit Winkel auf der X-Achse.</p>

    <div class="table-wrapper">
      <table class="data-table">
        <thead>
          <tr>
            <th>Winkel (°)</th>
            <th>IK</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>90°</td>
            <td><input class="angle-input" data-angle="90" type="number" step="any" placeholder="IK bei 90°"></td>
          </tr>
          <tr>
            <td>75°</td>
            <td><input class="angle-input" data-angle="75" type="number" step="any" placeholder="IK bei 75°"></td>
          </tr>
          <tr>
            <td>60°</td>
            <td><input class="angle-input" data-angle="60" type="number" step="any" placeholder="IK bei 60°"></td>
          </tr>
          <tr>
            <td>45°</td>
            <td><input class="angle-input" data-angle="45" type="number" step="any" placeholder="IK bei 45°"></td>
          </tr>
          <tr>
            <td>30°</td>
            <td><input class="angle-input" data-angle="30" type="number" step="any" placeholder="IK bei 30°"></td>
          </tr>
          <tr>
            <td>15°</td>
            <td><input class="angle-input" data-angle="15" type="number" step="any" placeholder="IK bei 15°"></td>
          </tr>
          <tr>
            <td>0°</td>
            <td><input class="angle-input" data-angle="0" type="number" step="any" placeholder="IK bei 0°"></td>
          </tr>
        </tbody>
      </table>
    </div>

    <div class="table-actions">
      <div class="button-group">
        <button id="plotAngleBtn">Zeichnen</button>
        <button id="resetAngleBtn" type="button">Zurücksetzen</button>
      </div>
      <div id="angleError" class="status"></div>
    </div>

    <div class="dataset-toggles">
      <label><input type="checkbox" id="toggleAngle" checked> IK(φ) anzeigen</label>
    </div>

    <div class="chart-container">
      <canvas id="angleChart" height="120"></canvas>
    </div>
  </div>

  <div class="container">
    <h2>Diagramm: I = f(U) für unterschiedliche Helligkeitsstufen</h2>
    <p>Trage hier die gemessenen <strong>U</strong>-Werte sowie die zugehörigen <strong>I</strong>-Werte für die Helligkeitsstufen 10 und 8 und zusätzlich deine berechnete <strong>P(U)</strong>-Kennlinie ein.</p>

    <div class="table-wrapper">
      <table class="data-table">
        <thead>
          <tr>
            <th>U</th>
            <th>I (Stufe 10)</th>
            <th>I (Stufe 8)</th>
            <th>P(U)</th>
          </tr>
        </thead>
        <tbody id="brightnessBody"></tbody>
      </table>
    </div>

    <div class="table-actions">
      <div class="button-group">
        <button id="plotBrightnessBtn">Zeichnen</button>
        <button id="resetBrightnessBtn" type="button">Zurücksetzen</button>
        <button id="addBrightnessRowBtn" type="button">+ Zeile</button>
      </div>
      <div id="brightnessError" class="status"></div>
    </div>

    <div class="dataset-toggles">
      <label><input type="checkbox" id="toggleLevel10" checked> I(U) Stufe 10 anzeigen</label>
      <label><input type="checkbox" id="toggleLevel8" checked> I(U) Stufe 8 anzeigen</label>
      <label><input type="checkbox" id="togglePower" checked> P(U) anzeigen</label>
    </div>

    <div class="chart-container">
      <canvas id="brightnessChart" height="120"></canvas>
    </div>
  </div>

  <script>
    let chartInstance = null;
    let angleChartInstance = null;
    let brightnessChartInstance = null;

    const measurementBody = document.getElementById('measurementBody');
    const brightnessBody = document.getElementById('brightnessBody');
    const INITIAL_MEASUREMENT_ROWS = 6;
    const INITIAL_BRIGHTNESS_ROWS = 6;

    function calculateScaleBounds(values) {
      if (!values.length) {
        return { min: 0, max: 1, step: 1 };
      }

      let minVal = Math.min(...values);
      let maxVal = Math.max(...values);

      if (minVal === maxVal) {
        const padding = Math.abs(minVal) * 0.5 || 1;
        minVal -= padding;
        maxVal += padding;
      }

      const range = maxVal - minVal;
      const roughStep = range / 5 || Math.abs(maxVal) / 5 || 1;
      const magnitude = Math.pow(10, Math.floor(Math.log10(roughStep)));
      const niceSteps = [1, 2, 5, 10];
      let step = niceSteps.map(n => n * magnitude).find(s => roughStep <= s);
      if (!step) {
        step = niceSteps[niceSteps.length - 1] * magnitude;
      }

      const minTick = minVal < 0 ? Math.floor(minVal / step) * step : 0;
      const maxTick = Math.ceil(maxVal / step) * step;

      return { min: minTick, max: maxTick, step };
    }

    function calculateScaleWithFixedStep(values, stepSize) {
      if (!values.length) {
        return { min: 0, max: stepSize, step: stepSize };
      }

      const minVal = Math.min(...values);
      const maxVal = Math.max(...values);
      let minTick = Math.floor(minVal / stepSize) * stepSize;
      let maxTick = Math.ceil(maxVal / stepSize) * stepSize;

      if (minTick === maxTick) {
        maxTick += stepSize;
      }

      return { min: minTick, max: maxTick, step: stepSize };
    }

    function updateDatasetVisibility(chart, label, visible) {
      if (!chart) return;
      const datasetIndex = chart.data.datasets.findIndex(ds => ds.label === label);
      if (datasetIndex === -1) return;
      chart.setDatasetVisibility(datasetIndex, visible);
      chart.update();
    }

    function connectToggle(checkboxId, chartAccessor, label) {
      const checkbox = document.getElementById(checkboxId);
      if (!checkbox) return;
      checkbox.addEventListener('change', () => {
        updateDatasetVisibility(chartAccessor(), label, checkbox.checked);
      });
    }

    function parseNumber(value) {
      const normalized = value.replace(',', '.');
      const num = Number(normalized);
      return isNaN(num) ? null : num;
    }

    function createMeasurementInput(className, placeholder) {
      const input = document.createElement('input');
      input.type = 'text';
      input.inputMode = 'decimal';
      input.placeholder = placeholder;
      input.className = `measurement-input ${className}`;
      return input;
    }

    function addBrightnessRow() {
      const row = document.createElement('tr');
      const uCell = document.createElement('td');
      const i10Cell = document.createElement('td');
      const i8Cell = document.createElement('td');
      const pCell = document.createElement('td');

      uCell.appendChild(createMeasurementInput('brightness-u', 'U-Wert'));
      i10Cell.appendChild(createMeasurementInput('brightness-i10', 'I Stufe 10'));
      i8Cell.appendChild(createMeasurementInput('brightness-i8', 'I Stufe 8'));
      pCell.appendChild(createMeasurementInput('brightness-p', 'P-Wert'));

      row.appendChild(uCell);
      row.appendChild(i10Cell);
      row.appendChild(i8Cell);
      row.appendChild(pCell);
      brightnessBody.appendChild(row);
    }

    function addMeasurementRow() {
      const row = document.createElement('tr');
      const eCell = document.createElement('td');
      const ulCell = document.createElement('td');
      const ikCell = document.createElement('td');

      eCell.appendChild(createMeasurementInput('input-e', 'E-Wert'));
      ulCell.appendChild(createMeasurementInput('input-ul', 'UL-Wert'));
      ikCell.appendChild(createMeasurementInput('input-ik', 'IK-Wert'));

      row.appendChild(eCell);
      row.appendChild(ulCell);
      row.appendChild(ikCell);
      measurementBody.appendChild(row);
    }

    function collectMeasurementData() {
      const rows = Array.from(measurementBody.querySelectorAll('tr'));
      const eArr = [];
      const ulArr = [];
      const ikArr = [];

      for (const row of rows) {
        const eVal = row.querySelector('.input-e').value.trim();
        const ulVal = row.querySelector('.input-ul').value.trim();
        const ikVal = row.querySelector('.input-ik').value.trim();
        const anyFilled = eVal || ulVal || ikVal;

        if (!anyFilled) {
          continue;
        }

        if (!eVal || !ulVal || !ikVal) {
          return { error: 'Bitte jede ausgefüllte Zeile komplett ausfüllen.' };
        }

        const eNum = parseNumber(eVal);
        const ulNum = parseNumber(ulVal);
        const ikNum = parseNumber(ikVal);

        if (eNum === null || ulNum === null || ikNum === null) {
          return { error: 'Bitte nur gültige Zahlen verwenden (Komma oder Punkt).' };
        }

        eArr.push(eNum);
        ulArr.push(ulNum);
        ikArr.push(ikNum);
      }

      if (!eArr.length) {
        return { error: 'Bitte mindestens eine vollständige Messreihe eintragen.' };
      }

      return { eArr, ulArr, ikArr };
    }

    function resetMeasurementTable() {
      const rows = Array.from(measurementBody.querySelectorAll('tr'));
      rows.forEach(row => row.querySelectorAll('input').forEach(input => input.value = ''));
      while (measurementBody.rows.length > INITIAL_MEASUREMENT_ROWS) {
        measurementBody.deleteRow(-1);
      }
    }

    function collectBrightnessData() {
      const rows = Array.from(brightnessBody.querySelectorAll('tr'));
      const uArr = [];
      const iLevel10Arr = [];
      const iLevel8Arr = [];
      const pArr = [];

      for (const row of rows) {
        const uVal = row.querySelector('.brightness-u').value.trim();
        const i10Val = row.querySelector('.brightness-i10').value.trim();
        const i8Val = row.querySelector('.brightness-i8').value.trim();
        const pVal = row.querySelector('.brightness-p').value.trim();
        const anyFilled = uVal || i10Val || i8Val || pVal;

        if (!anyFilled) {
          continue;
        }

        if (!uVal || !i10Val || !i8Val || !pVal) {
          return { error: 'Bitte jede ausgefüllte Zeile komplett ausfüllen.' };
        }

        const uNum = parseNumber(uVal);
        const i10Num = parseNumber(i10Val);
        const i8Num = parseNumber(i8Val);
        const pNum = parseNumber(pVal);

        if (uNum === null || i10Num === null || i8Num === null || pNum === null) {
          return { error: 'Bitte nur gültige Zahlen verwenden (Komma oder Punkt).' };
        }

        uArr.push(uNum);
        iLevel10Arr.push(i10Num);
        iLevel8Arr.push(i8Num);
        pArr.push(pNum);
      }

      if (!uArr.length) {
        return { error: 'Bitte mindestens eine vollständige Messreihe eintragen.' };
      }

      return { uArr, iLevel10Arr, iLevel8Arr, pArr };
    }

    function resetBrightnessTable() {
      const rows = Array.from(brightnessBody.querySelectorAll('tr'));
      rows.forEach(row => row.querySelectorAll('input').forEach(input => input.value = ''));
      while (brightnessBody.rows.length > INITIAL_BRIGHTNESS_ROWS) {
        brightnessBody.deleteRow(-1);
      }
    }

    for (let i = 0; i < INITIAL_MEASUREMENT_ROWS; i++) {
      addMeasurementRow();
    }

    document.getElementById('addRowBtn').addEventListener('click', () => {
      addMeasurementRow();
    });

    for (let i = 0; i < INITIAL_BRIGHTNESS_ROWS; i++) {
      addBrightnessRow();
    }

    document.getElementById('addBrightnessRowBtn').addEventListener('click', () => {
      addBrightnessRow();
    });

    document.getElementById('plotBtn').addEventListener('click', () => {
      const errorDiv = document.getElementById('error');
      errorDiv.textContent = '';

      const measurementData = collectMeasurementData();

      if (measurementData.error) {
        errorDiv.textContent = measurementData.error;
        return;
      }

      const { eArr, ulArr, ikArr } = measurementData;

      const combined = eArr.map((e, i) => ({
        e,
        ul: ulArr[i],
        ik: ikArr[i]
      }));

      const ulPoints = combined.map(p => ({ x: p.e, y: p.ul }));
      const ikPoints = combined.map(p => ({ x: p.e, y: p.ik }));
      const xValues = combined.map(point => point.e);
      const minX = xValues.length ? xValues[0] : 0;
      let maxX = xValues.length ? Math.max(...xValues) : 1;
      if (minX === maxX) {
        maxX = minX + 1;
      }
      const scale = calculateScaleWithFixedStep([...ulPoints, ...ikPoints].map(p => p.y), 50);

      const ctx = document.getElementById('myChart').getContext('2d');

      if (chartInstance) {
        chartInstance.destroy();
      }

      chartInstance = new Chart(ctx, {
        type: 'line',
        data: {
          datasets: [
            {
              label: 'UL(E) [mV]',
              data: ulPoints,
              yAxisID: 'yUL',
              tension: 0,
              pointRadius: 4,
              borderWidth: 2
            },
            {
              label: 'IK(E) [mA]',
              data: ikPoints,
              yAxisID: 'yIK',
              tension: 0,
              pointRadius: 4,
              borderWidth: 2,
              borderDash: [5, 5]
            }
          ]
        },
        options: {
          responsive: true,
          interaction: {
            mode: 'nearest',
            intersect: false
          },
          plugins: {
            tooltip: {
              callbacks: {
                title: (items) => 'E = ' + items[0].label
              }
            },
            legend: {
              position: 'top'
            },
            title: {
              display: true,
              text: 'UL = f(E) (links) und IK = f(E) (rechts)'
            }
          },
          scales: {
            x: {
              type: 'linear',
              title: {
                display: true,
                text: 'E'
              },
              min: minX,
              max: maxX
            },
            yUL: {
              type: 'linear',
              position: 'left',
              title: {
                display: true,
                text: 'UL (mV)'
              },
              min: scale.min,
              max: scale.max,
              ticks: {
                stepSize: scale.step
              }
            },
            yIK: {
              type: 'linear',
              position: 'right',
              title: {
                display: true,
                text: 'IK (mA)'
              },
              grid: {
                drawOnChartArea: false
              },
              min: scale.min,
              max: scale.max,
              ticks: {
                stepSize: scale.step
              }
            }
          }
        }
      });

      const toggleUL = document.getElementById('toggleUL');
      const toggleIK = document.getElementById('toggleIK');
        if (toggleUL) {
          updateDatasetVisibility(chartInstance, 'UL(E) [mV]', toggleUL.checked);
        }
        if (toggleIK) {
          updateDatasetVisibility(chartInstance, 'IK(E) [mA]', toggleIK.checked);
        }
    });

    document.getElementById('resetBtn').addEventListener('click', () => {
      resetMeasurementTable();
      document.getElementById('error').textContent = '';
      if (chartInstance) {
        chartInstance.destroy();
        chartInstance = null;
      }
    });

    const angleInputs = Array.from(document.querySelectorAll('.angle-input'));
    const angles = angleInputs.map(input => Number(input.dataset.angle));

    document.getElementById('plotAngleBtn').addEventListener('click', () => {
      const angleError = document.getElementById('angleError');
      angleError.textContent = '';

      const filledAngles = [];
      const filledValues = [];

      angleInputs.forEach((input, index) => {
        const value = input.value.trim();
        if (value !== '') {
          const num = Number(value.replace(',', '.'));
          if (!isNaN(num)) {
            filledAngles.push(angles[index]);
            filledValues.push(num);
          }
        }
      });

      if (!filledValues.length) {
        angleError.textContent = 'Bitte mindestens einen IK-Wert eingeben.';
        return;
      }

      const anglePoints = filledAngles.map((angle, idx) => ({ x: angle, y: filledValues[idx] }))
        .sort((a, b) => a.x - b.x);
      const scale = calculateScaleBounds(anglePoints.map(point => point.y));
      const ctx = document.getElementById('angleChart').getContext('2d');

      if (angleChartInstance) {
        angleChartInstance.destroy();
      }

      angleChartInstance = new Chart(ctx, {
        type: 'line',
        data: {
          datasets: [
            {
              label: 'IK(φ)',
              data: anglePoints,
              tension: 0,
              pointRadius: 4,
              borderWidth: 2
            }
          ]
        },
        options: {
          responsive: true,
          interaction: {
            mode: 'nearest',
            intersect: false
          },
          plugins: {
            legend: {
              position: 'top'
            },
            title: {
              display: true,
              text: 'IK in Abhängigkeit vom Winkel'
            }
          },
          scales: {
            x: {
              type: 'linear',
              title: {
                display: true,
                text: 'Winkel (°)'
              },
              min: 0
            },
            y: {
              title: {
                display: true,
                text: 'IK'
              },
              min: scale.min,
              max: scale.max,
              ticks: {
                stepSize: scale.step
              }
            }
          }
        }
      });

      const toggleAngle = document.getElementById('toggleAngle');
      if (toggleAngle) {
        updateDatasetVisibility(angleChartInstance, 'IK(φ)', toggleAngle.checked);
      }
    });

    document.getElementById('resetAngleBtn').addEventListener('click', () => {
      angleInputs.forEach(input => input.value = '');
      document.getElementById('angleError').textContent = '';
      if (angleChartInstance) {
        angleChartInstance.destroy();
        angleChartInstance = null;
      }
    });

    document.getElementById('plotBrightnessBtn').addEventListener('click', () => {
      const errorDiv = document.getElementById('brightnessError');
      errorDiv.textContent = '';

      const brightnessData = collectBrightnessData();

      if (brightnessData.error) {
        errorDiv.textContent = brightnessData.error;
        return;
      }

      const { uArr, iLevel10Arr, iLevel8Arr, pArr } = brightnessData;

      const combined = uArr.map((u, i) => ({
        u,
        i10: iLevel10Arr[i],
        i8: iLevel8Arr[i],
        p: pArr[i]
      })).sort((a, b) => a.u - b.u);

      const level10Points = combined.map(p => ({ x: p.u, y: p.i10 }));
      const level8Points = combined.map(p => ({ x: p.u, y: p.i8 }));
      const powerPoints = combined.map(p => ({ x: p.u, y: p.p }));
      const currentScale = calculateScaleBounds([...level10Points, ...level8Points].map(point => point.y));
      const powerScale = calculateScaleBounds(powerPoints.map(point => point.y));

      const ctx = document.getElementById('brightnessChart').getContext('2d');

      if (brightnessChartInstance) {
        brightnessChartInstance.destroy();
      }

      brightnessChartInstance = new Chart(ctx, {
        type: 'line',
        data: {
          datasets: [
            {
              label: 'I(U) Stufe 10',
              data: level10Points,
              yAxisID: 'yCurrent',
              borderColor: '#d97706',
              backgroundColor: 'rgba(217, 119, 6, 0.1)',
              tension: 0,
              pointRadius: 4,
              borderWidth: 2
            },
            {
              label: 'I(U) Stufe 8',
              data: level8Points,
              yAxisID: 'yCurrent',
              borderColor: '#0ea5e9',
              backgroundColor: 'rgba(14, 165, 233, 0.1)',
              tension: 0,
              pointRadius: 4,
              borderWidth: 2
            },
            {
              label: 'P(U)',
              data: powerPoints,
              yAxisID: 'yPower',
              borderColor: '#16a34a',
              backgroundColor: 'rgba(22, 163, 74, 0.1)',
              tension: 0,
              pointRadius: 4,
              borderWidth: 2,
              borderDash: [6, 4]
            }
          ]
        },
        options: {
          responsive: true,
          interaction: {
            mode: 'nearest',
            intersect: false
          },
          plugins: {
            legend: {
              position: 'top'
            },
            title: {
              display: true,
              text: 'I = f(U) (Stufen 10 & 8) und P = f(U)'
            }
          },
          scales: {
            x: {
              type: 'linear',
              title: {
                display: true,
                text: 'U'
              },
              min: 0
            },
            yCurrent: {
              title: {
                display: true,
                text: 'I'
              },
              min: currentScale.min,
              max: currentScale.max,
              ticks: {
                stepSize: currentScale.step
              }
            },
            yPower: {
              position: 'right',
              title: {
                display: true,
                text: 'P'
              },
              grid: {
                drawOnChartArea: false
              },
              min: powerScale.min,
              max: powerScale.max,
              ticks: {
                stepSize: powerScale.step
              }
            }
          }
        }
      });

      const toggleLevel10 = document.getElementById('toggleLevel10');
      const toggleLevel8 = document.getElementById('toggleLevel8');
      const togglePower = document.getElementById('togglePower');
      if (toggleLevel10) {
        updateDatasetVisibility(brightnessChartInstance, 'I(U) Stufe 10', toggleLevel10.checked);
      }
      if (toggleLevel8) {
        updateDatasetVisibility(brightnessChartInstance, 'I(U) Stufe 8', toggleLevel8.checked);
      }
      if (togglePower) {
        updateDatasetVisibility(brightnessChartInstance, 'P(U)', togglePower.checked);
      }
    });

    document.getElementById('resetBrightnessBtn').addEventListener('click', () => {
      resetBrightnessTable();
      document.getElementById('brightnessError').textContent = '';
      if (brightnessChartInstance) {
        brightnessChartInstance.destroy();
        brightnessChartInstance = null;
      }
    });

    connectToggle('toggleUL', () => chartInstance, 'UL(E) [mV]');
    connectToggle('toggleIK', () => chartInstance, 'IK(E) [mA]');
    connectToggle('toggleAngle', () => angleChartInstance, 'IK(φ)');
    connectToggle('toggleLevel10', () => brightnessChartInstance, 'I(U) Stufe 10');
    connectToggle('toggleLevel8', () => brightnessChartInstance, 'I(U) Stufe 8');
    connectToggle('togglePower', () => brightnessChartInstance, 'P(U)');
  </script>
</body>
</html>
